local BHALL_LIB_VERSION=0.1;
function activationSequence (ids,property) local prop = property or "state" local timeTable = {};  for i,id in pairs(ids) do time = fibaro:getModificationTime(id,prop);  table.insert(timeTable,tonumber(time),tonumber(id)); end;  table.sort(timeTable); return timeTable;end;
function dayrecorder( storageVariable) local startOfDayEpoch = tableToEpochtime(timestringToTable("00:00:01")); local startSource = startedByDevice(); local id = tonumber(startSource["deviceID"]); local property = tostring(startSource["propertyName"]); local value, modificationTime = fibaro:get(id, property); local adjModTime = modificationTime - startOfDayEpoch; local toStore = {id,property, value};  fibaro:debug("Storing value ".. value .. " of property ".. property .. " for device " .. id); local storageTable = json.decode(fibaro:getGlobal(tostring(storageVariable))); table.insert(storageTable,toStore); local out = json.encode(storageTable); fibaro:setGlobal(tostring(storageVariable),out); fibaro:debug("Stored value ".. value .. " of property ".. property .. " for device " .. id);end;
function logLastActivity(variableName) local var = tostring(variableName) or "ACTIVITY_LAST_SEEN"; local now = os.time();  fibaro:setGlobal(var,tostring(now));end;
function hasBeenActivity(timeWindow, variableName) local var = tostring(variableName) or "ACTIVITY_LAST_SEEN"; local now = os.time(); local lastActivity = tonumber(fibaro:setGlobal(var)); local timeDiffMinutes = (now - lastActivity)/60; return (timeDiffMinutes < tonumber(timeWindow));end;
function hasChangedSince(id,property,seconds,minutes,hours,debugChangeTimeEpoch) local min = minutes or 0; local h = hours or 0; local lastchange = tonumber(debugChangeTimeEpoch) or tonumber(fibaro:getModificationTime(id,property)); local now = os.time(); local printFunc = print; if (fibaro or {}).debug then 
function printFunc(...) ; return fibaro:debug(...); end; end; printFunc("Testing device time " .. lastchange.. " Epoch time, which is ".. os.date("%Y-%m-%d %X",lastchange)); printFunc("against current time ".. now .. " Epoch time, which is ".. os.date("%Y-%m-%d %X",now)); return(lastchange >= (now - seconds - min * 60 - h * 60 * 60));end;
function riskOfMold(hum, temp, levelDescriptions) local ld = levelDescriptions or {"Risk of mold growth","Mold growth happening (8v)","Mold growth happening (4v)"};  
function high15Plus (temp) lhum= (89-91)/10*temp + 95;return(lhum);end; 
function high15Minus (temp) lhum= (91.5-100)/15*temp + 104;return(lhum);end;  
function med10Plus (temp) lhum= (81-87)/(50-15)*temp + 93;return(lhum);end; 
function med10Minus (temp) lhum= (87.5-100)/(15-0)*temp + 100;return(lhum);end;  
function low15Plus (temp) lhum= 80;return(lhum);end; 
function low15Minus (temp) lhum= (80-100)/(15-0)*temp + 98;return(lhum);end;       if(temp <= 0) then return(false); end;  if ( ( temp > 15 and hum >= high15Plus(temp) ) or ( temp <= 15 and hum >= high15Minus(temp) )  )  then return(ld[3]); elseif ( ( temp > 10 and hum >= med10Plus(temp) ) or ( temp <= 10 and hum >= med10Minus(temp) )  )  then return(ld[2]); elseif ( ( temp > 15 and hum >= low15Plus(temp) ) or ( temp <= 15 and hum >= low15Minus(temp) )  )  then return(ld[1]); else return(false); end;end;
function startLevelChangeWithDur(dimmerID,startLevel,stopLevel,durationSeconds,delayBetweenSteps) local currentLevel = startLevel; local timeStepSeconds = delayBetweenSteps or 2; local deltaPerSecond = (stopLevel - startLevel) / durationSeconds *timeStepSeconds; local newLevel = currentLevel + deltaPerSecond; local currentLevelFromDevice = 0; fibaro:debug("STARTING light increase"); repeat fibaro:debug("Setting level value ".. newLevel); fibaro:call(dimmerID,"setValue",newLevel); currentLevel = newLevel;  fibaro:sleep(timeStepSeconds* 1000);   newLevel = currentLevel + deltaPerSecond;   until ( newLevel > stopLevel )  fibaro:debug("DONE light increase");end;
function lightSelect(currentLuxLevel, conditionsTable) local currentLux = tonumber(currentLuxLevel); out = {}; if (not type(conditionsTable) == "table")  then error("Array of arrays expected as 'conditionsTable' argument.") end; for id, lux in pairs(conditionsTable) do if type(lux) == "table" then for nlux,level in pairs(lux) do nout = {}; nout[nlux] = level; table.insert(out,nout); end; elseif type(lux) == "number" then if tonumber(currentLuxLevel) <= tonumber(lux) then table.insert(out,id); end; else error("The value stored in the table should be either a numeric value or a {lux,level} table ") end; end; return(out);end;
function runLigthingSetup(onTable)  if (fibaro or {}).call then 
function callFunc(...) ; return fibaro:call(...); end; else 
function callFunc(...) print(...); end; end;  local IDOrONCommand = nil; for _,IDOrONCommand in pairs(onTable) do  if type(IDOrONCommand) == "table" then IDOrONCommand = {IDOrONCommand[1],"setLevel",IDOrONCommand[2]}; else IDOrONCommand = {IDOrONCommand,"turnOn"}; end; callFunc(unpack(IDOrONCommand)); end;end;
function startedManually () local startSource = fibaro:getSourceTrigger(); return( startSource["type"] == "other");end;
function startedByVariable () local startSource = fibaro:getSourceTrigger(); if startSource["type"] == "global" then return (startSource["name"]); else return false; end;end;
function startedByDevice () local startSource = fibaro:getSourceTrigger();  if startSource["type"] == "property" then return ({deviceID=startSource["deviceID"], propertyName=startSource["propertyName"]}); else return false; end;end;
function sceneNotCurrentlyRunning() local sceneCount = tonumber(fibaro:countScenes()); return (sceneCount == 1);end;
function onButUnplugged(id,threshold) local t = threshold or 15; local state = tonumber(fibaro:getValue(id, "value")); local pow = tonumber(fibaro:getValue(id, "power")); return(state == 1 and pow > t);end;
function buttonPressed(id,descriptionstring,descriptiontable) local dtab = descriptiontable or 
nodonSceneTableVerbose; local inDesc = tostring(descriptionstring) ; local scene = tonumber(fibaro:getValue(id, "sceneActivation")); local desc = tostring(dtab[scene]); return(inDesc == desc);end;
nodonSceneTableVerbose = { [10]="Button 1 Single Press", [20]="Button 2 Single Press", [30]="Button 3 Single Press", [40]="Button 4 Single Press", [13]="Button 1 Double Press", [23]="Button 2 Double Press", [33]="Button 3 Double Press", [43]="Button 4 Double Press", [12]="Button 1 Hold Press", [22]="Button 2 Hold Press", [32]="Button 3 Hold Press", [42]="Button 4 Hold Press", [11]="Button 1 Hold Released", [21]="Button 2 Hold Released", [31]="Button 3 Hold Released", [41]="Button 4 Hold Released"};
nodonSceneTable = { [10]="1SP", [20]="2SP", [30]="3SP", [40]="4SP", [13]="1DP", [23]="2DP", [33]="3DP", [43]="4DP", [12]="1HP", [22]="2HP", [32]="3HP", [42]="4HP", [11]="1HR", [21]="2HR", [31]="3HR", [41]="4HR"};
zwavemeSceneTableVerbose = { [11]="Button 1 Single Click", [21]="Button 2 Single Click", [31]="Button 3 Single Click", [41]="Button 4 Single Click", [12]="Button 1 Double Click", [22]="Button 2 Double Click", [32]="Button 3 Double Click", [42]="Button 4 Double Click", [13]="Button 1 Press and hold", [23]="Button 2 Press and hold", [33]="Button 3 Press and hold", [43]="Button 4 Press and hold", [14]="Button 1 Click and then Press and hold", [24]="Button 2 Click and then Press and hold", [34]="Button 3 Click and then Press and hold", [44]="Button 4 Click and then Press and hold", [15]="Button 1 Click and then Press and hold", [25]="Button 2 Click and then Press and hold", [35]="Button 3 Click and then Press and hold", [45]="Button 4 Click and then Press and hold", [16]="Button 1 Click and then Press and hold long time", [26]="Button 2 Click and then Press and hold long time", [36]="Button 3 Click and then Press and hold long time", [46]="Button 4 Click and then Press and hold long time"};
zwavemeSceneTable = { [11]="1SC", [21]="2SC", [31]="3SC", [41]="4SC", [12]="1DC", [22]="2DC", [32]="3DC", [42]="4DC", [13]="1PH", [23]="2PH", [33]="3PH", [43]="4PH", [14]="1C_PH", [24]="2C_PH", [34]="3C_PH", [44]="4C_PH", [15]="1PLH", [25]="2PLH", [35]="3PLH", [45]="4PLH", [16]="1C_PLH", [26]="1C_PLH", [36]="1C_PLH", [46]="1C_PLH"};
function isTime (timeString, offsetMinutes, secondsWindow) local timeTable = timestringToTable(timeString); local timeEpoch = tableToEpochtime (timeTable); local timeWithOffset = timeEpoch + (offsetMinutes * 60); local now = os.time(); return ( math.abs(timeWithOffset - now) <= secondsWindow );end;
function timeIsInRange (startTimeString, endTimeString) local startTimeTable = timestringToTable(startTimeString); local endTimeTable = timestringToTable(endTimeString); local startTimeEpoch = tableToEpochtime (startTimeTable); local endTimeEpoch = tableToEpochtime (endTimeTable); local newEndTimeTable = endTimeTable;  if (endTimeEpoch < startTimeEpoch) then endTimeEpoch = endTimeEpoch + 24*3600;    newEndTimeTable = os.date("*t",endTimeEpoch); end;  if (startTimeTable.isdst == false and newEndTimeTable.isdst == true) then    endTimeEpoch = endTimeEpoch + 3600; elseif (startTimeTable.isdst == true and newEndTimeTable.isdst == false) then   endTimeEpoch = endTimeEpoch - 3600; end; local now = os.time(); return ( (startTimeEpoch <= now ) and (endTimeEpoch >= now));end;
function isDayOfWeek (dayList) local today = os.date("%a",os.time()); local longToday = os.date("%A",os.time()); for i, v in ipairs(dayList) do if today == v or longToday == v then return(true); end; end; return(false);end;
function isWeekDay () local today = tonumber(os.date("%w",os.time()));  return (not (today == 0 or today == 6));end;
function isWeekDayTomorrow () local today = tonumber(os.date("%w",os.time()));  return (not (today == 5 or today == 6));end;
function isWeekEnd () local today = tonumber(os.date("%w",os.time())); return (today == 0 or today == 6);end;
function isWeekEndTomorrow () local today = tonumber(os.date("%w",os.time())); return (today == 5 or today == 6);end;
function beforeTime(time, offset) local timeEpoch = tableToEpochtime(timestringToTable(time)); local startOfDay = tableToEpochtime(timestringToTable("00:00")); local off = offset or 0; timeEpoch = timeEpoch + off; local now = os.time(); return( (now < timeEpoch) and (now >= startOfDay ));end;
function afterTime(time, offset) local timeEpoch = tableToEpochtime(timestringToTable(time)); local endOfDay = tableToEpochtime(timestringToTable("23:59:59")); local off = offset or 0; timeEpoch = timeEpoch + off; local now = os.time(); return( (now > timeEpoch) and (now <= endOfDay ));end;
function datetimeTableTrue (dateTable) local nowTodayTable = os.date("*t"); local scorekeeper = false; for k,v in pairs(dateTable) do  if type (v) == "number" then if not (nowTodayTable[k] == dateTable[k]) then return(false); end; elseif type (v) == "table" then  for ki, vi in pairs(v) do if (nowTodayTable[k] == v[ki]) then scorekeeper = true; end; end; if not scorekeeper then return(false) end; scorekeeper = false; else if not debug == nil then fibaro:debug("List of options in a field in the table should only contain numbers") else error("List of options in a field in the table should only contain numbers") end; end; end; return(true);end;
function stringTimeAdjust(stringTime,adjustmentMinutes,extraSecondsAdjustment) local extraSecs = extraSecondsAdjustment or 0; local timeEpoch = tableToEpochtime(timestringToTable(stringTime)); local adjustSeconds = tonumber(adjustmentMinutes) * 60 + tonumber(extraSecs); local newEpochTime = timeEpoch + adjustSeconds; local newTime = tostring(os.date("%X",newEpochTime)); return(newTime);end;
function runIf(shouldRun, toRun, sleepSeconds ) local delay = sleepSeconds or 0; if (type(toRun) == "function" and shouldRun ) then toRun(); elseif ( type(toRun) == "table"  and shouldRun ) then for k,v in pairs(toRun) do v = tonumber(v); if ( fibaro:isSceneEnabled(v)) then fibaro:startScene(v); else fibaro:debug("Not running disabled scene ID:".. tostring(k)); end; end; end; fibaro:sleep(delay*1000);end;
function shouldStopHeater (heaterOnTime, autoOffTime, blockedByOutsideTemperature) local now = os.time();   local notblock = (not blockedByOutsideTemperature) or false; return (  notblock  or  ( now - heaterOnTime ) >= (3600 * autoOffTime) );end;
function iso8601DateTime(timestamp) return(os.date("%Y-%m-%d %X",tonumber(timestamp)));end;return datetime;
function timeToStartCarHeater (readyTime, tempOutside, eco, heaterON) local timeEpoch = datetime.tableToEpochtime(timestringToTable(readyTime)); local now = os.time(); local heaterStarted = heaterON or false; local startTime = timeEpoch; if (eco) then if (tempOutside <= -15) then  startTime = timeEpoch - (3600*2); elseif (tempOutside <= -10) then  startTime = timeEpoch - (3600*1); elseif (tempOutside <= 0) then  startTime = timeEpoch - (3600*1); elseif (tempOutside <= 10) then  startTime = timeEpoch - (3600*0.5); else  return(false); end; else if (tempOutside <= -20) then  startTime = timeEpoch - (3600*3); elseif (tempOutside <= -10) then  startTime = timeEpoch - (3600*2); elseif (tempOutside <= 0) then  startTime = timeEpoch - (3600*1); elseif (tempOutside <= 10) then  startTime = timeEpoch - (3600*1); else  return(false); end; end;  return ( (not heaterON) and (startTime <= now) and (now <= timeEpoch));end;local 
function timestringToTable (time) local dateTable = os.date("*t");  local g =  string.gmatch(time, "%d+"); local hour = g() ; local minute = g() or 0; local second = g() or 0;  dateTable["hour"] = hour; dateTable["min"] = minute; dateTable["sec"] = second; return(dateTable);end;local 
function tableToEpochtime (t) local now = os.date("*t"); local outTime = os.time{year=t.year or now.year, month=t.month or now.month,day=t.day or now.day,hour=t.hour or now.hour,min=t.min or now.min,sec=t.sec or now.sec,isdst=t.isdst or now.isdst}; return(outTime);end;
function isDaytime() local stat = tostring(fibaro:getGlobalValue("TimeOfDay")); return(sting.lower(stat) == "day");end;
function isNighttime() local stat = tostring(fibaro:getGlobalValue("TimeOfDay")); return(sting.lower(stat) == "night");end;
function isMorning() local stat = tostring(fibaro:getGlobalValue("TimeOfDay")); return(sting.lower(stat) == "morning");end;
function isEvening() local stat = tostring(fibaro:getGlobalValue("TimeOfDay")); return(sting.lower(stat) == "evening");end;
function debugTable(node)  local printFunc = print if (fibaro or {}).debug then 
function printFunc(...); return fibaro:debug(...); end; end;  local 
function tab(amt) local str = ""; for i=1,amt do str = str .. "\t"; end; return str; end; local cache, stack = {},{}; local depth = 1; local output_str = "{\n"; while true do if not (cache[node]) then cache[node] = {}; end; local size = 0; for k,v in pairs(node) do size = size + 1; end; local cur_index = 1; for k,v in pairs(node) do if not (cache[node][k]) then cache[node][k] = {}; end;  if (cache[node][k][v] == nil) then cache[node][k][v] = true; if (string.find(output_str,"}",output_str:len())) then output_str = output_str .. ",\n"; elseif not (string.find(output_str,"\n",output_str:len())) then output_str = output_str .. "\n"; end; local key; if (type(k) == "userdata") then key = "[userdata]"; elseif (type(k) == "string") then key = "['"..tostring(k).."']"; else key = "["..tostring(k).."]"; end; if (type(v) == "table") then output_str = output_str .. tab(depth) .. key .. " = {\n"; table.insert(stack,node); table.insert(stack,v); break; elseif (type(v) == "userdata") then output_str = output_str .. tab(depth) .. key .. " = userdata"; elseif (type(v) == "string") then output_str = output_str .. tab(depth) .. key .. " = '"..v.."'"; else output_str = output_str .. tab(depth) .. key .. " = "..tostring(v); end; if (cur_index == size) then output_str = output_str .. "\n" .. tab(depth-1) .. "}"; else output_str = output_str .. ","; end; else  if (cur_index == size) then output_str = output_str .. "\n" .. tab(depth-1) .. "}"; end; end; cur_index = cur_index + 1; end; if (#stack > 0) then node = stack[#stack]; stack[#stack] = nil; depth = cache[node] == nil and depth + 1 or depth - 1; else break; end; end; printFunc(output_str);end;
function tableValueExists(tab, value) for k,v in pairs(tab) do if value == v then return true; end; end; return false;end;local 
function test_tableValueExists() local a = {}; a[12] = "Tolvan"; a["13"] = "Tretton"; assert(tableValueExists(a,"Tolvan") == true,"Tolvan finns" ); assert(tableValueExists(a,"Tretton") == true,"Tretton finns" );end;
function keyUnion(t1, t2) local outTab = {}; for k1, v1 in pairs(t1) do for k2, v2 in pairs(t2) do outTab[k1] = true; outTab[k2] = true; end; end; return(outTab);end;
function seq(start, stop, step) local myStep = myStep or 1; local out = {}; local i = start; local store = start; while (store <= stop) do out[i] = store; i = i + 1; store = store + myStep; end; return out;end;
function tableToTable (t) local out = {} for k, v in pairs(t) do out[tostring(v)] = k; end; return out;end;
function arrayContainsValue(tab, value) for k,v in pairs(tab) do if tostring(v) == tostring(value) then return(true); end; end; return(false);end;
function arrayContainsKey(tab, key) for k,v in pairs(tab) do if tostring(k) == tostring(key) then return(true); end; end; return(false);end;
function loadHomeTable (variableName) local var = tostring(variableName) or "HomeTable"; local jT = json.decode(fibaro:getGlobalValue(var));  if jT == {} then fibaro:debug("Could not load content from the HomeTable variable \'".. var .. "\'. Please make sure the variable exists."); return(false); else fibaro:debug("Got HomeTable"); return(jT); end;end;
function getOutSideTemperature() local 
function isEmpty(s) return s == nil or s == ''; end; temp = tonumber(fibaro:getValue(3, "Temperature")); if(isEmpty(temp)) then return(nil); end; return(temp);end;
function getOutSideHumidity() local 
function isEmpty(s) return s == nil or s == ''; end; temp = tonumber(fibaro:getValue(3, "Temperature")); if(isEmpty(temp)) then return(nil); end; return(temp);end;
function weatherIsClear() cond = lower(tostring(fibaro:getValue(3, "WeatherConditionConverted"))); return (cond == "clear")end;
function weatherIsCloudy() cond = lower(tostring(fibaro:getValue(3, "WeatherConditionConverted"))); return (cond == "cloudy")end;
function isRainyWeather() cond = lower(tostring(fibaro:getValue(3, "WeatherConditionConverted"))); return (cond == "rainy")end;
function isSnowing() cond = lower(tostring(fibaro:getValue(3, "WeatherConditionConverted"))); return (cond == "snow")end;
function isStorming() cond = lower(tostring(fibaro:getValue(3, "WeatherConditionConverted"))); return (cond == "storm")end;
function isFog() cond = lower(tostring(fibaro:getValue(3, "WeatherConditionConverted"))); return (cond == "fog")end;